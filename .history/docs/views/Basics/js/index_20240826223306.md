---
next:
    text: '设计模式'
    link: 'views/Basics/js/designPattern'
---
# javascript 知识
## 介绍

::: tip
JavaScript 是一门弱类型、动态、基于原型的脚本语言，它支持面向对象、命令式、声明式、函数式等多种编程范式。JavaScript 的设计目标是使网络浏览器具有动态交互性，因此它最初被设计为在浏览器中执行脚本语言。然而，随着 JavaScript 的不断发展，它已经超出了浏览器的限制，现在可以在各种环境中运行，包括服务器端、桌面应用程序和移动设备。
:::

## 1. 基础数据类型

-   基本类型：String、Number、Boolean、Null、Undefined、Symbol、BigInt
-   引用类型：Object

::: tip
Symbol 是 ES6 引入的一种新的原始数据类型，表示独一无二的值。Symbol 值通过 Symbol 函数生成，可以接受一个字符串作为参数，表示对 Symbol 的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。

BigInt 是 ES2020 引入的一种新的原始数据类型，表示任意精度的整数。BigInt 可以表示大于 2^53 - 1 的整数，而 Number 类型只能表示 53 位以内的整数。BigInt 可以通过在整数后面加上 n 来表示，例如 123n。
:::

::: danger
数据可以分为原始数据累心和饮用数据类型

-   1. 栈：原始数据类型：String、Number、Boolean、Null、Undefined、Symbol、BigInt
-   2. 堆：引用数据类型：Object 数组 函数
       不同
-   1. 原始数据类型存储在栈中，值与值之间独立存在，互不影响
-   2. 引用数据类型存储在堆中，堆中存放的是对象的地址，栈中存放的是对象的引用地址，当复制引用数据类型时，复制的是对象的引用地址，指向同一个堆中的对象，因此修改一个会影响另一个
-   3. 原始数据类型比较的是值，引用数据类型比较的是引用地址

:::

### 堆 与 栈

-   堆：存储引用类型数据，如对象、数组、函数等，堆中的数据在程序运行期间可以被动态创建和销毁。
-   栈：存储基本类型数据，如数字、字符串、布尔值等，以及引用类型数据的引用地址。栈中的数据在程序运行期间遵循先进后出的原则，即后进先出。

## 2. 数据类型检测的方式有哪些

-   2.1 typeof：typeof 操作符用于获取一个变量的类型，返回一个字符串。typeof 操作符返回的值可以是以下几种：

```
console.log(typeof 123); // number
console.log(typeof 'abc'); // string
console.log(typeof true); // boolean
console.log(typeof null); // object
console.log(typeof undefined); // undefined
console.log(typeof Symbol('foo')); // symbol
console.log(typeof BigInt(123)); // bigint
console.log(typeof function() {}); // function
console.log(typeof {}); // object
console.log(typeof []); // object
console.log(typeof new Date()); // object
console.log(typeof /regex/); // object
```

其中数组，对象，null，undefined，symbol，bigint，function，都是引用类型，因此 typeof 操作符无法检测到这些类型的值。

-   2.2 instanceof：instanceof 操作符用于检测一个对象是否是某个构造函数的实例。instanceof 操作符返回一个布尔值，表示对象是否是某个构造函数的实例。因此 instanceof 只能正确判断饮用数据类型

```javascript
console.log(123 instanceof Number); // false
console.log("abc" instanceof String); // false
console.log(true instanceof Boolean); // false
console.log(null instanceof Object); // false
console.log(undefined instanceof Object); // false
console.log(Symbol("foo") instanceof Symbol); // false
console.log(BigInt(123) instanceof BigInt); // false
console.log(function () {} instanceof Function); // true
console.log({} instanceof Object); // true
console.log([] instanceof Array); // true
console.log(new Date() instanceof Date); // true
console.log(/regex/ instanceof RegExp); // true
```

-   2.3 constructor：constructor 属性返回一个对象的构造函数。constructor 属性返回的值是一个函数，表示该对象是由哪个构造函数创建的。如果创建一个对象嘞改变它的原型 constructor 就不能用来判断数据类型了

```javascript
console.log((123).constructor === Number); // true
console.log("abc".constructor === String); // true
console.log(true.constructor === Boolean); // true
console.log(null.constructor === Object); // false
console.log(undefined.constructor === Object); // false
console.log(Symbol("foo").constructor === Symbol); // true
console.log(BigInt(123).constructor === BigInt); // true
console.log(function () {}.constructor === Function); // true
console.log({}.constructor === Object); // true
console.log([].constructor === Array); // true
console.log(new Date().constructor === Date); // true
console.log(/regex/.constructor === RegExp); // true
```

-   2.4 Object.prototype.toString.call()：Object.prototype.toString.call() 方法用于获取对象的字符串表示形式，返回一个字符串。该方法通过调用对象的 toString 方法来获取对象的字符串表示形式。

```javascript
console.log(Object.prototype.toString.call(123)); // [object Number]
console.log(Object.prototype.toString.call("abc")); // [object String]
console.log(Object.prototype.toString.call(true)); // [object Boolean]
console.log(Object.prototype.toString.call(null)); // [object Null]
console.log(Object.prototype.toString.call(undefined)); // [object Undefined]
console.log(Object.prototype.toString.call(Symbol("foo"))); // [object Symbol]
console.log(Object.prototype.toString.call(BigInt(123))); // [object BigInt]
console.log(Object.prototype.toString.call(function () {})); // [object Function]
console.log(Object.prototype.toString.call({})); // [object Object]
console.log(Object.prototype.toString.call([])); // [object Array]
console.log(Object.prototype.toString.call(new Date())); // [object Date]
console.log(Object.prototype.toString.call(/regex/)); // [object RegExp]
```

::: tip
obj.toString() 与 Object.prototype.toString.call(obj) 的区别

-   obj.toString() 方法返回一个表示该对象的字符串，该字符串由对象类型和值组成。
-   Object.prototype.toString.call(obj) 方法返回一个表示该对象的字符串，该字符串由对象类型和值组成。
    toString 是 Object 的一个方法 而 array function 等类型作为 Object 的实例 都重写了 toString 方法 而不会调用 object 的 toString 方法的原型 toString 方法

:::

## 3. 判读数组的那些方法

-   3.1 Array.isArray()：Array.isArray() 方法用于判断一个对象是否为数组。该方法返回一个布尔值，表示对象是否为数组。

```
Array.isArray([1, 2, 3]); // true
```

-   3.2 object.prototype.toString.call()：object.prototype.toString.call() 方法用于获取对象的字符串表示形式，返回一个字符串。该方法通过调用对象的 toString 方法来获取对象的字符串表示形式。

```
console.log(Object.prototype.toString.call([1, 2, 3])); // [object Array]
```

-   3.3 instanceof：instanceof 操作符用于检测一个对象是否是某个构造函数的实例。instanceof 操作符返回一个布尔值，表示对象是否是某个构造函数的实例。

```javascript
console.log([1, 2, 3] instanceof Array); // true
console.log([1, 2, 3] instanceof Object); // true
```

-   3.4 constructor：constructor 属性返回一个对象的构造函数。constructor 属性返回一个对象的构造函数。constructor 属性返回一个对象的构造函数。

```javascript
console.log((1, 2, 3).constructor === Array); // false
console.log((1, 2, 3).constructor === Object); // true
```

## 4 null 和 undefined 的区别

::: tip
null 和 undefined 都是 JavaScript 中的特殊值，用于表示一个空值或未定义的值。但是它们在 JavaScript 中有区别。

-   null：空对象
-   undefined：未定义
:::

## instanceof 操作符的实现原理

:::
instanceof 操作符用于检测一个对象是否是某个构造函数的实例。instanceof 操作符返回一个布尔值，表示对象是否是某个构造函数的实例。因此 instanceof 只能正确判断引用数据类型。
:::

```javascript
function myInstanceof(left, right) {
    // 获取对象的原型
    let proto = Object.getPrototypeOf(left);
    // 获取构造函数的 prototype 对象
    let prototype = right.prototype;

    // 判断构造函数的 prototype 对象是否在对象的原型链上
    while (true) {
        if (!proto) return false;
        if (proto === prototype) return true;
        proto = Object.getPrototypeOf(proto);
    }
}
```
# es6

## 6. var let const 的区别

-   var：var 是 JavaScript 中的一个变量声明语句，用于声明一个变量。var 可以重复声明同一个变量，并且可以在声明之前使用。
-   let：let 是 JavaScript 中的一个变量声明语句，用于声明一个块级作用域的变量。let 可以重复声明同一个变量，但是只能在声明之前使用。
-   const：const 是 JavaScript 中的一个变量声明语句，用于声明一个只读的常量。const 不能重复声明同一个变量，并且只能在声明之前使用。 const 的值不能被修改，但是可以修改对象属性。

## 7.箭头函数和普通函数的区别

::: tip
箭头函数：箭头函数是一种新的函数定义方式，语法上与普通函数不同。箭头函数没有自己的 this、arguments、super 和 new.target，而是使用外层函数的 this、arguments、super 和 new.target。 
普通函数：普通函数是一种使用 function 关键字定义的函数，具有自己的 this、arguments、super 和 new.target。
:::

- 1.箭头函数比普通韩式更加简洁
- 2.箭头函数没有自己的 this，arguments，super 和 new.target。
- 3.箭头函数不能作为构造函数使用。
- 4.箭头函数不能使用 yield 关键字。
- 5.箭头函数继承来的this 指向永远不会变
- 6.call() apply() bind()等方法不能改变this 指向

# JavaScript 基础
## 8. new 的实现原理

::: tip
new 运算符用于创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。
:::

```javascript
function myNew(constructor, ...args) {
    // 创建一个空对象
    const obj = {};
    // 将空对象的原型指向构造函数的原型
    obj.__proto__ = constructor.prototype;
    // 将构造函数的 this 指向空对象
    const result = constructor.apply(obj, args);
    // 如果构造函数返回一个对象，则返回该对象，否则返回空对象
    return typeof result === "object" && result !== null ? result : obj;
}
```

## 9. map 和object 区别

||map|                object                |
|:--:|:--:|:------------------------------------:|
|意外的键|map默认不包含任何键，只包含显示插入的键| object有一个原型，原型链上的键名有可能和自己在对象上设置的键名冲突 |
|键的类型|map的键可以是任意类型，包括对象|        object的键只能是字符串或Symbol         |
|键的顺序|map的键的顺序与插入顺序一致|           object的键的顺序是随机的            |
|size|map的size属性返回键的数量|          object的键值对个数只能手动计算          |
|迭代|map的迭代器返回的是键值对，可以同时迭代键和值|          object的迭代器返回的是键名，不能同时迭代键名和值          |

## map 和 weakMap 的区别

map 和 weakMap 都是 JavaScript 中的一种数据结构，用于存储键值对。但是它们在实现上有一些区别。
1. map 是一个普通的数据结构，可以存储任意类型的键和值。weakMap 只能存储对象类型的键，并且键对象不能被垃圾回收机制回收。
2. map 是一个有序的集合，键值对按照插入顺序存储。weakMap 是一个无序的集合，键值对没有顺序。
3. map 可以通过 get() 方法获取键对应的值。weakMap 不能通过 get() 方法获取键对应的值。
4. map 可以通过 has() 方法判断键是否存在。weakMap 不能通过 has() 方法判断键是否存在。

map 的操作方法
-   set(key, value)：向 map 中添加一个新的键值对。
-   get(key)：返回指定键对应的值。
-   has(key)：判断 map 中是否包含指定键。
-   delete(key)：从 map 中删除指定键对应的键值对。
-   clear()：清空 map 中的所有键值对。
-   keys()：返回一个迭代器，迭代 map 中的所有键。
-   values()：返回一个迭代器，迭代 map 中的所有值。
-   entries()：返回一个迭代器，迭代 map 中的所有键值对。
-   forEach(callbackFn, thisArg)：遍历 map 中的所有键值对，并执行回调函数。
-   size：返回 map 中的键值对数量。

weakMap 的操作方法
- set(key, value)：向 weakMap 中添加一个新的键值对。
- get(key)：返回指定键对应的值。
- delete(key)：从 weakMap 中删除指定键对应的键值对
weakMap 的键名所引用的对象，垃圾回收机制会自动删除对应的键值对。


## DOM 和 BOM

::: tip
1. DOM 是 Document Object Model 的缩写，即文档对象模型。它是一种用于操作 HTML 和 XML 文档的 API。
2. Bom 是 Browser Object Model 的缩写，即浏览器对象模型。它是一种用于操作浏览器窗口的 API。
:::

## 常见的DOM操作方法

1. 获取DOM 节点
 ```
  document.getElementById("id"); // 按id查询
  document.getElementsByTagName("tagName"); // 按标签名查询
  document.getElementsByClassName("className"); // 按类名查询
  document.querySelector("selector"); // 按选择器查询
```

2. 创建DOM节点

```angular2html
document.createElement("tagName"); // 创建一个元素节点
document.createTextNode("text"); // 创建一个文本节点
document.createComment("comment"); // 创建一个注释节点
document.createDocumentFragment(); // 创建一个文档片段节点
document.createAttribute("attrName"); // 创建一个属性节点
document.createEvent("eventType"); // 创建一个事件节点
document.createRange(); // 创建一个范围节点
document.createNodeIterator(); // 创建一个节点迭代器
document.createTreeWalker(); // 创建一个树遍历器
document.createExpression(); // 创建一个表达式节点
document.createExpression();
```

3 修改节点

```
node.appendChild(child); // 添加子节点
node.insertBefore(newChild, refChild);// 交换j点位置
```

4 删除节点

```css
node.removeChild(child);
node.replaceChild(newChild, oldChild);
node.cloneNode(deep);   
node.normalize();
node.isEqualNode(otherNode);
```

# for in 和 for of 的区别

::: tip
for in 循环和 for of 循环都是用于遍历对象的属性的循环语句。它们的区别如下：
for in 循环用于遍历对象的属性，包括不可枚举的属性。for of 循环用于遍历可迭代对象，如数组、字符串、Set、Map 等。
:::

## 数组方法

1. push() 方法向数组的末尾添加一个或多个元素，并返回新的长度。
2. pop() 方法从数组的末尾删除一个元素，并返回删除的元素。
3. shift() 方法从数组的开头删除一个元素，并返回删除的元素。
4. unshift() 方法向数组的开头添加一个或多个元素，并返回新的长度。
5. splice() 方法向数组的指定位置添加或删除元素，并返回被删除的元素。
6. concat() 方法将两个或多个数组拼接成一个新数组。
7. join() 方法将数组中的元素拼接成一个字符串。
8. indexOf() 方法返回数组中第一个匹配的元素的索引。
9. lastIndexOf() 方法返回数组中最后一个匹配的元素的索引。
10. every() 方法用于判断数组中的所有元素是否满足指定的条件，如果满足则返回 true，否则返回 false。
11. some() 方法用于判断数组中的至少一个元素是否满足指定的条件，如果满足则返回 true，否则返回 false。
12. filter() 方法用于创建一个新数组，包含满足指定条件的元素。
13. map() 方法用于创建一个新数组，包含将原始数组中的每个元素映射到新数组中的元素。
14. reduce() 方法用于将数组中的所有元素减少为一个值。
15. flat() 方法用于将嵌套的数组展平为一维数组。
16. flatMap() 方法用于将嵌套的数组展平为一维数组，并将每个元素映射到新数组中的元素。
17. includes() 方法用于判断数组是否包含指定的值，如果包含则返回 true，否则返回 false。
18. toString() 方法用于将数组转换为字符串。
19. toLocaleString() 方法用于将数组转换为本地字符串。
20. valueOf() 方法用于将数组转换为原始值。
21. keys() 方法用于返回一个包含数组中所有键的迭代器。
22. values() 方法用于返回一个包含数组中所有值的迭代器。
23. entries() 方法用于返回一个包含数组中所有键值对的迭代器。
24. forEach() 方法用于遍历数组中的每个元素，并执行指定的函数
25. find() 方法用于查找数组中满足指定条件的第一个元素，并返回该元素。
26. findIndex() 方法用于查找数组中满足指定条件的第一个元素的索引，并返回该索引。
27. sort() 方法用于对数组进行排序，并返回排序后的数组。
28. reverse() 方法用于将数组中的元素反转，并返回反转后的数组
29. includes() 方法用于判断数组是否包含指定的值，如果包含则返回 true，否则返回 false。
30. reduceRight() 方法用于将数组中的所有元素从右向左减少为一个值。
31. slice() 方法用于创建一个新数组，包含原始数组中指定范围内的元素。

## 字符串方法
1. charAt() 方法返回指定位置的字符。
2. charCodeAt() 方法返回指定位置的字符的 Unicode 编码。
3. concat() 方法用于连接两个或多个字符串。
4. endsWith() 方法用于判断字符串是否以指定的子字符串结尾。
5. includes() 方法用于判断字符串是否包含指定的子字符串。
6. indexOf() 方法返回指定子字符串在字符串中首次出现的位置。
7. lastIndexOf() 方法返回指定子字符串在字符串中最后出现的位置。
8. match() 方法用于匹配字符串中的指定子字符串。
9. repeat() 方法用于将字符串重复指定的次数。
10. search() 方法用于检索字符串中指定的子字符串。
11. slice() 方法用于提取字符串的一部分，并返回一个新的字符串。
12. split() 方法用于将字符串分割成一个字符串数组。
13. startsWith() 方法用于判断字符串是否以指定的子字符串开头。
14. sub() 方法用于替换字符串中的指定子字符串。
15. substring() 方法用于提取字符串的一部分，并返回一个新的字符串。
16. toLocaleLowerCase() 方法用于将字符串转换为小写。
17. toLocaleUpperCase() 方法用于将字符串转换为大写。
18. toUpperCase() 方法用于将字符串转换为大写。
19. toLowerCase() 方法用于将字符串转换为小写。
20. toString() 方法用于将字符串转换为字符串。
21. valueOf() 方法用于将字符串转换为原始值。

## Object
1. Object.assign() 方法用于将源对象的所有可枚举属性复制到目标对象。
2. Object.keys() 方法用于返回一个由对象的可枚举属性组成的数组。
3. Object.values() 方法用于返回一个由对象的所有属性值组成的数组。
4. Object.entries() 方法用于返回一个由对象的键值对组成的数组。
5. Object.getOwnPropertyNames() 方法用于返回一个由对象的所有属性名组成的数组。
6. Object.getOwnPropertySymbols() 方法用于返回一个由对象的所有符号属性名组成的数组。
7. Object.getOwnPropertyDescriptors() 方法用于返回一个由对象的所有属性描述符组成的对象。
8. Object.getPrototypeOf() 方法用于返回对象的原型。
9. Object.setPrototypeOf() 方法用于设置对象的原型。
10. Object.is() 方法用于判断两个值是否严格相等。
11. Object.isFrozen() 方法用于判断一个对象是否被冻结。
12. Object.isSealed() 方法用于判断一个对象是否被密封。
13. Object.isExtensible() 方法用于判断一个对象是否可扩展。
14. Object.preventExtensions() 方法用于阻止一个对象被扩展。
15. Object.seal() 方法用于密封一个对象。
16. Object.freeze() 方法用于冻结一个对象。
17. Object.create() 方法用于创建一个新对象，使用指定的原型对象。
18.object.defineProperty() 方法用于定义一个对象的属性。
18. Object.defineProperties() 方法用于定义一个对象的多个属性。

## Reflect

::: tip
Reflect 是一个内置的对象，它提供与对象相关的方法。这些方法与 Object 对象的方法类似，但是它们使用 Reflect 对象上的方法，而不是使用对象本身。
:::

1. Reflect.apply() 方法用于调用一个函数，并在指定的 this 值和参数上执行。
2. Reflect.construct() 方法用于创建一个新的对象实例，并在指定的构造函数上执行。
3. Reflect.defineProperty() 方法用于定义一个对象的属性。
4. Reflect.deleteProperty() 方法用于删除一个对象的属性。
5. Reflect.get() 方法用于获取一个对象的属性值。
6. Reflect.getOwnPropertyDescriptor() 方法用于获取一个对象的属性描述符。
7. Reflect.getPrototypeOf() 方法用于获取一个对象的原型
8. Reflect.has() 方法用于判断一个对象是否具有指定的属性。
9. Reflect.isExtensible() 方法用于判断一个对象是否可扩展。
10. Reflect.ownKeys() 方法用于获取一个对象的所有属性键。
11. Reflect.preventExtensions() 方法用于阻止一个对象被扩展。
12. Reflect.set() 方法用于设置一个对象的属性值。
13. Reflect.setPrototypeOf() 方法用于设置一个对象的原型。
14. Reflect.unscopables() 方法用于返回一个对象的不可枚举

## Promise

::: tip
 Promise 是一个异步编程的解决方案，用于解决回调函数的嵌套问题。
:::

1. Promise.all() 方法用于将多个 Promise 对象合并成一个 Promise 对象，并返回一个 Promise 对象。
2. Promise.race() 方法用于将多个 Promise 对象合并成一个 Promise 对象，并返回一个 Promise 对象。
3. Promise.reject() 方法用于返回一个拒绝的 Promise 对象。
4. Promise.resolve() 方法用于返回一个已完成的 Promise 对象。
5. Promise.allSettled() 方法用于将多个 Promise 对象合并成一个 Promise 对象，并返回一个 Promise 对象。
6. Promise.any() 方法用于将多个 Promise 对象合并成一个 Promise 对象，并返回一个 Promise 对象。
7. Promise.prototype.catch() 方法用于捕获 Promise 链中的错误。
8. Promise.prototype.finally() 方法用于无论 Promise 链是否成功完成，都执行指定的函数。
9. Promise.prototype.then() 方法用于处理 Promise 链中的成功和失败情况。
10. Promise.prototype.try() 方法用于尝试执行一个 Promise 链，并返回一个 Promise 对象。
11. Promise.prototype.catch() 方法用于捕获 Promise 链中的错误。

## proxy

::: tip
Proxy 是一个内置的对象，它提供了一种拦截 JavaScript 操作的方式。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，
因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”
:::

- 1.get(target, propKey, receiver)：拦截对象属性的读取
- 2.set(target, propKey, value, receiver)：拦截对象属性的设置
- 3.has(target, propKey)：拦截 propKey in proxy 的操作
- 4.deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作
- 5.ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。
- 6.getOwnPropertyDescriptor(target, propKey)：拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
- 7.defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
- 8.preventExtensions(target)：拦截 Object.preventExtensions(proxy)，返回一个布尔值。
- 9.getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy)，返回一个对象。
- 10.isExtensible(target)：拦截 Object.isExtensible(proxy)，返回一个布尔值。
- 11.setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto)
- 12.apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如 proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
- 13.construct(target, args, newTarget)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(...args)。

## ajax , axios fetch 